// The MIT License (MIT)

// Copyright (c) 2015 Elliott Richerson, Carlos Aari Lotfipour

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in 
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

module.exports = function Validate(operations,errors) {
	var validate = {
		isEmpty: function isEmpty(data) {
			if(typeof(data) == "number" || typeof(data) == "boolean") {
				return false;
			}
			if(typeof(data) == "undefined" || data == null) {
				return true;
			}
			if(typeof(data.length) != 'undefined') {
				return data.length === 0;
			}
			var count = 0;
			for(var i in data) {
				if(data.hasOwnProperty(i)) {
					count++;
				}
			}
			return count === 0;
		},
		schema: function schema(sch, pre) {
			var valid = true;
			var errorArray = [];

			// Extract Fields from Schema Which Are Not Auto-Generated by Server
			var nonAutoSchema = sch.filter(function(s) {
				return !s.auto;
			});

			// Fields Provided
			var fields = Object.keys(pre);

			// For Each Attribute Required By Form
			for (var i = 0; i < nonAutoSchema.length; i++) {
				var nonAutoScheme = nonAutoSchema[i];
				var fieldAttribute = nonAutoScheme.attribute;

				var isFieldMissing = false;
				var isFieldEmpty = false;
				var fieldValue = null;

				// Check if Field is Missing or Empty
				isFieldMissing = !(fields.indexOf(fieldAttribute) in fields);
				if(!isFieldMissing) {
					fieldValue = pre[fieldAttribute].trim();
					isFieldEmpty = validate.isEmpty(fieldValue);
				}

				// The Field is Missing or Empty
				if(isFieldMissing || isFieldEmpty) {
					// Required fields missing results in a validation error
					if(nonAutoScheme.required) {
						valid = false;
						errorArray.push(errors.form.REQUIRES_ATTRIBUTE(fieldAttribute));
					}
					// Otherwise this field can be ignored as empty
					else {
						pre[fieldAttribute] = "";
					}
					// Continue to the next field check without collecting futher errors on this
					continue;
				}
				// The Field is Present, Check for Validity
				else {
					if (typeof(nonAutoScheme.test) == "function" && nonAutoScheme.test.length == 2) {
						var test = nonAutoScheme.test(fieldAttribute, fieldValue === null ? "" : fieldValue);
						if(test.valid) {
							pre[fieldAttribute] = test.data;
						}
						else {
							valid = false;
							errorArray = errorArray.concat(test.errors);
						}
					}
					// Required fields must have an associated 'test' validation function.
					// which takes the attribute name and attribute value as parameters.
					else {
						valid = false;
						errorArray.push(errors.form.REQUIRES_ATTRIBUTE_TEST(requiredFieldAttribute));
					}
				}
			} // end for

			if(valid) {
				return { valid: valid, data: pre };
			}
			else {
				return { valid: valid, errors: errorArray };
			}
		},
		attribute: function attribute(sch, pre, att) {
			// Extract Scheme from Schema Which Defines Attribute
			var attributeSchemes = sch.filter(function(s) {
				return s.attribute == att;
			});
			var attributeScheme = attributeSchemes[0];
			if (typeof(attributeScheme.test) == "function" && attributeScheme.test.length == 2) {
				var test = attributeScheme.test(att, pre === null ? "" : pre);
				if(test.valid) {
					return { valid: true, data: test.data };
				}
				else {
					return { valid: false, errors: test.errors };
				}
			}
			return { valid: false, errors: [errors.UNKNOWN_ERROR("single attribute " + att + " failed validation")] };
		},
		id: function id(pre) {
			if (Number.isInteger(Number(pre))) { 
				return { valid: true, data: pre };
			}
			return { valid: false, error: "id not an integer" };
		},
		operation: function operation(pre) {
			var validOperations = [];
			for(var key in operations) {
				validOperations.push(operations[key]);
			}
			if (validOperations.indexOf(pre) in validOperations) {
				return { valid: true, data: pre };
			}
			return { valid: false, error: "operation undefined" };
		}
	};
	return validate;
};